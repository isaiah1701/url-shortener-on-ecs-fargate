name: Deploy

on:
  workflow_run:
    workflows: ["Build"]
    types: [completed]

permissions:
  contents: read
  id-token: write

concurrency:
  group: deploy-${{ github.event.workflow_run.head_branch }}
  cancel-in-progress: true

jobs:
  deploy:
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest

    steps:
      # Checkout the exact commit that triggered Build
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha }}

      # Decide env from branch -> dev|staging|prod
      - name: Derive env from branch
        id: derive
        shell: bash
        run: |
          BRANCH="${{ github.event.workflow_run.head_branch }}"
          case "$BRANCH" in
            dev)     ENV_NAME=dev ;   ECR_REPO=dev-urlshortener ;;
            staging) ENV_NAME=staging; ECR_REPO=staging-urlshortener ;;
            main)    ENV_NAME=prod ;  ECR_REPO=prod-urlshortener ;;
            *) echo "::error ::Unsupported branch ${BRANCH}"; exit 1 ;;
          esac
          echo "env_name=${ENV_NAME}"   >> "$GITHUB_OUTPUT"
          echo "ecr_repo=${ECR_REPO}"   >> "$GITHUB_OUTPUT"
          echo "branch=${BRANCH}"       >> "$GITHUB_OUTPUT"

      # Load root .env (for AWS_REGION, ECR_ACCOUNT_ID, IMAGE_NAME, etc.)
      - name: Load .env
        id: loadenv
        shell: bash
        run: |
          test -f .env || { echo "::error::.env missing"; exit 1; }
          set -a; source .env; set +a
          grep -Ev '^\s*#' .env >> "$GITHUB_ENV"
          echo "AWS_REGION=${AWS_REGION}"         >> "$GITHUB_OUTPUT"
          echo "ECR_ACCOUNT_ID=${ECR_ACCOUNT_ID}" >> "$GITHUB_OUTPUT"
          echo "IMAGE_NAME=${IMAGE_NAME}"         >> "$GITHUB_OUTPUT"

      # Configure AWS with a single OIDC role
      - name: Configure AWS (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.ROLE_ARN || format('arn:aws:iam::{0}:role/gha-oidc-simple', steps.loadenv.outputs.ECR_ACCOUNT_ID) }}
          aws-region: ${{ steps.loadenv.outputs.AWS_REGION }}

      # Compute the image URI produced by Build (tagged with head_sha)
      - name: Compute image URI
        id: image
        shell: bash
        env:
          AWS_REGION:     ${{ steps.loadenv.outputs.AWS_REGION }}
          ECR_ACCOUNT_ID: ${{ steps.loadenv.outputs.ECR_ACCOUNT_ID }}
          ECR_REPO:       ${{ steps.derive.outputs.ecr_repo }}
        run: |
          SHA="${{ github.event.workflow_run.head_sha }}"
          ECR_REG="${ECR_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
          IMAGE_URI="${ECR_REG}/${ECR_REPO}:${SHA}"
          echo "image_uri=${IMAGE_URI}" >> "$GITHUB_OUTPUT"
          echo "Using image ${IMAGE_URI}"

      # (Optional) Ensure repo exists â€” harmless if already created by infra
      - name: Ensure ECR repository exists
        env:
          ECR_REPO: ${{ steps.derive.outputs.ecr_repo }}
        run: |
          aws ecr describe-repositories --repository-names "${ECR_REPO}" >/dev/null 2>&1 || \
          aws ecr create-repository    --repository-name   "${ECR_REPO}" >/dev/null

      # --- Terraform toolchain & deploy ---
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.x
          terraform_wrapper: false

      - name: Terraform Init
        working-directory: infra/envs/${{ steps.derive.outputs.env_name }}
        run: terraform init -input=false

      - name: Terraform Apply
        working-directory: infra/envs/${{ steps.derive.outputs.env_name }}
        env:
          TF_VAR_image_uri: ${{ steps.image.outputs.image_uri }}
        run: terraform apply -input=false -auto-approve
